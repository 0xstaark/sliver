{"tutorials":[{"name":"1 - Getting Started","content":"This course will use the latest Sliver build, you can download it from [insert local web server].\n\n`sliver-server` is the binary you want to use to run the Sliver C2 server, `sliver-client` is solely a client to connect to a Sliver C2 server. Sliver server also acts as a client on its own, so you don’t necessarily run sliver server and client separately.\n\nFirst time running Sliver will take a couple seconds as its retrieving its dependencies, consecutive executions will be much faster. Go ahead and launch the `sliver-server`.\n\n```asciinema\n{\"src\": \"/asciinema/startup.cast\", \"cols\": \"132\", \"rows\": \"28\", \"idleTimeLimit\": 8}\n```\n\nLet's take a couple minutes to discuss what Sliver actually is and how its setup.\n\n![Alt text](/images/Architecture.png)\n\nNow that Sliver is running, lets generate and execute your first implant to try out some of the basic features of Sliver, for now we’re going to run everything on the local host.\n\nHere's what we're going to do: \n* Generate your implant using the `generate` command as shown below.\n* Start HTTP listener on port 80\n* Execute implant in a separate terminal\n\n```asciinema\n{\"src\": \"/asciinema/first-implant.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nNow let’s select our implant and run our first command using the `use` command.\n\n```bash\n[server] sliver > use\n? Select a session or beacon: \nSESSION  1884a365  RELATED_EARDRUM  [::1]:49153      test.local  tester  darwin/amd64\n[*] Active session RELATED_EARDRUM (1884a365-085f-4506-b28e-80c481730fd0)\n\n[server] sliver (RELATED_EARDRUM) > pwd\n\n[*] /Users/tester/tools\n```\n\nOnce you have reached this point, go ahead and explore some of the commands listed below. In each case first checkout the commands help using the **`-h`** flag then try it out!\n\n```bash\nExploring and interacting with the filesystem\n\nFilesystem\n  cat               Dump file to stdout\n  cd                Change directory\n  cp                Copy a file\n  download          Download a file\n  grep              Search for strings that match a regex within a file or directory\n  head              Grab the first number of bytes or lines from a file\n  ls                List current directory\n  memfiles          List current memfiles\n  mkdir             Make a directory\n  mount             Get information on mounted filesystems\n  mv                Move or rename a file\n  pwd               Print working directory\n  rm                Remove a file or directory\n  tail              Grab the last number of bytes or lines from a file\n  upload            Upload a file\n```\n\n```asciinema\n{\"src\": \"/asciinema/filesystem.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nGetting some environmental information\n```bash\nInfo\n  env               List environment variables\n  getgid            Get session process GID\n  getpid            Get session pid\n  getuid            Get session process UID\n  info              Get session info\n  ping              Send round trip message to implant (does not use ICMP)\n  screenshot        Take a screenshot\n  whoami            Get session user execution context\n```\nExecute a binary\n\n```asciinema\n{\"src\": \"/asciinema/execute.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nRunning an interactive shell\n\n```asciinema\n{\"src\": \"/asciinema/shell.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```"},{"name":"2 - Beacons vs Sessions","content":"# Beacons vs Sessions\n\nSliver implants support two types of connections, sessions and beacons.\n\nSessions use long-poling connections, which means they use a single TCP connection which is constantly open. Beacons on the other hand call back periodically, and will sleep when not active which can help keep their presence hidden.\n\nTypically during an engagement you will want to deploy a beacon on the target system, and switch to a session while doing more active enumeration activities.\n\nLet’s start with generating and deploying a beacon using `http`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_generation.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nYou can see the beacon callback times either in the `info` command or using `beacons watch`.\n\n```bash\n[server] sliver > beacons watch\n\n ID         Name            Transport   Username          Operating System   Last Check-In   Next Check-In\n========== =============== =========== ================= ================== =============== ===============\n 942c647c   TIRED_GIRAFFE   http(s)     tester   darwin/amd64       52s             12s\n\n```\n\nBeacon callback times and jitter can be set either during generation or on the fly using the `reconfig` command.\n\nThe example below sets the callback time to 5s with a 1s jitter.\n\n```bash\n[server] sliver (TIRED_GIRAFFE) > reconfig -i 5s -j 1s\n\n[*] Tasked beacon TIRED_GIRAFFE (b8aa6fd8)\n\n[+] TIRED_GIRAFFE completed task b8aa6fd8\n\n[*] Reconfigured beacon\n\n[server] sliver (TIRED_GIRAFFE) > info\n\n         Beacon ID: 942c647c-8409-4877-9fa2-b84a7f27ad45\n              Name: TIRED_GIRAFFE\n          Hostname: tester.local\n              UUID: c6de1a44-016a-5fbe-b76a-da56af41316d\n          Username: tester\n               UID: 501\n               GID: 20\n               PID: 55879\n                OS: darwin\n           Version:\n            Locale:\n              Arch: amd64\n         Active C2: https://127.0.0.1\n    Remote Address: 127.0.0.1:51803\n         Proxy URL:\n          Interval: 1m0s\n            Jitter: 30s\n     First Contact: Wed Apr 19 01:14:21 CEST 2023 (10m30s ago)\n      Last Checkin: Wed Apr 19 01:18:20 CEST 2023 (6m31s ago)\n      Next Checkin: Wed Apr 19 01:19:46 CEST 2023 (5m5s ago)\n```\n\nCommands issued for beacons can be viewed using `tasks`, the task state will indicate wether the command has completed or not.  The results of previously run tasks can be viewed using `tasks fetch`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_tasks.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nbeacon_tasks.cast\n\nSession can be spun up using the `interractive` command.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_interractive.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nBecause of the differences between sessions and beacons, certain commands like `upload` or `download` are slower on beacons due to the callback time. Others such as socks5 are not supported and only allowed for sessions. As a rule of thumb anything requiring higher network bandwith should be run from a session.\n\nLet’s switch to our newly created session and spin-up a `socks5` proxy.\n\n```bash\n\nsocks\n[server] sliver (TIRED_GIRAFFE) > use\n\n? Select a session or beacon: SESSION  131a60b9  TIRED_GIRAFFE  127.0.0.1:51969  tester.local  tester  darwin/amd64\n[*] Active session TIRED_GIRAFFE (131a60b9-db4f-4913-9064-18a17a0f09ab)\n\n[server] sliver (TIRED_GIRAFFE) > socks5 start\n\n[*] Started SOCKS5 127.0.0.1 1081\n⚠️  In-band SOCKS proxies can be a little unstable depending on protocol\n```\n\nYou can then point your browser to port 1081 to tunnel traffic through the implant to your target’s local network.\n\nTry out some of the previous commands and compare behaviour on beacons and sessions. Once you are done, you should remember to close your session using the `close` command.\n"},{"name":"3 - C2 Profiles and configuration","content":"# Advanced web traffic configuration\n\nWhen generating implants sliver uses a C2Profile configuration, which will be use to generate the effective network configuration of the implant. For example if configured to use /admin and /demo as callback urls, it might use one, the other or both allowing two implants using the same configuration to still seem slightly different from a network traffic perspective.\n\nC2 profile configurations can be seen using the `c2profile` command, which also allows import and export features.\n\nThe full list of possible configuration option can be found in the references section below, but for now lets instead customise the existing configuration.\n\nLets imagine we’re trying to breach a customer known for using ruby-on-rails. By default sliver will use:\n\n- `.woff` for staging\n- `.js` for poll requests\n- `.html` for key exchanges\n- `.png` for close session\n- `.php` for session messages\n\nLet’s go ahead and update the session messages and staging with something more realistic and remove all references to woff or php.\n\n```bash\n\"session_file_ext\": \".css\",\n\"stager_file_ext\": \".ico\",\n```\n\nTODO pull urls for ror, maybe from seclists ? \n\nThe next step is to restart the http listener and generate our new implant.\n\n```bash\nTODO\nasciinema export c2profile, updating extensions and paths\n```\n\nTODO\nasciinema import custom c2profile, restart job and spin new beacon\n\nIf you now look at the debug output you’ll notice we no longer have .php urls.\n\n```bash\n2023/04/25 15:27:41 httpclient.go:672: [http] segments = [oauth2 v1 authenticate auth], filename = index, ext = css\n2023/04/25 15:27:41 httpclient.go:482: [http] POST -> http://localhost/oauth2/v1/authenticate/auth/index.css?p=711x58387 (2228 bytes)\n2023/04/25 15:27:41 httpclient.go:488: [http] POST request completed\n2023/04/25 15:27:42 httpclient.go:287: Cancelling poll context\n2023/04/25 15:27:42 httpclient.go:672: [http] segments = [assets], filename = jquery, ext = js\n2023/04/25 15:27:42 httpclient.go:406: [http] GET -> http://localhost/assets/jquery.js?r=72074674\n2023/04/25 15:27:42 sliver.go:198: [recv] sysHandler 12\n2023/04/25 15:27:42 session.go:189: [http] send envelope ...\n2023/04/25 15:27:42 httpclient.go:672: [http] segments = [oauth v1 oauth2], filename = admin, ext = css\n2023/04/25 15:27:42 httpclient.go:482: [http] POST -> http://localhost/oauth/v1/oauth2/admin.css?j=56685386 (93 bytes)\n```\n\nIdeally during engagements your recon phase should inform your C2 infrastructure, reusing similar hosting providers, technologies and communication protocols can help your implant fly under the radar. "},{"name":"4 - HTTP Payload staging","content":""},{"name":"5 - Pivots","content":""},{"name":"6 - Scripting","content":""},{"name":"7 - Assemblies and Bofs","content":""}]}